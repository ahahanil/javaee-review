
设计模式分类
- 创建型模式
  - Abstract Factory
    - 抽象工厂一系列相关对象或相互依赖的对象创建一个接口。比如电脑对象创建包含CPU、主板等部件创建而不同部件又有不同厂商，抽象工厂接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法比如这里的部件创建
    - 具体的工厂实现代表的是一个产品族，比如Intel具体工厂创建Intel的CPU、主板等部件；AMD的创建AMD的CPU、主板等部件产品切换只需要切换一下具体工厂。
  - Builder
    - 建造模式(对象的创建模式)分离复杂对象的构建和表示。三种使用建造模式情况：
      - **需要生成的产品对象有复杂的内部结构**，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。
      - **需要生成的产品对象的属性相互依赖**。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。
      - 在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。
  - Factory Method
    - 工厂方法模式(多态性工厂)定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中完成各种实例化细节。
    - 示例中文件多种类型导出PDF、WORD... 工厂方法中定义类型导出接口工厂实现类中根据传入的类型决定实例化该类型对象导出
  - Static Factory Method
    - 简单工厂(静态工厂方法)由一个工厂对象决定创建出哪一种产品类的实例.
    - 示例中应用系统需要支持多种登录方式由简单工厂静态方法根据类型创建该类型的登录验证实例
  - Prototype
    - 原型模式也叫克隆模式
    - Java自带原型模式实现需要实现Cloneable标记型接口(如果一个类重写了clone()方法但没有实现Cloneable标记型接口调用时就会抛异常)
  - Singleton
- 结构型模式
  - Adapter
    - 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
    - 在BIO里字节流是无法直接赋值给字符流不同的类型接口，所以提供转换流把字节流转换为字符流这也是适配器模式一种应用
  - Bridge
  - Composite
  - Decorator
    - 装饰模式(包装模式)按照单一职责原则，某一个对象只专注于干一件事，而如果要扩展其职能的话，不如想办法分离出一个类来“包装”这个对象，而这个扩展出的类则专注于实现扩展功能。**将新功能动态地附加于现有对象而不改变现有对象的功能**
    - IO流中带缓冲区的流就是对基本流装饰包装在流的基础上扩展了缓冲区功能而不改变IO流现有功能
    - 再比如咖啡无论是加糖、加牛奶这些包装装饰都改变不了它还是咖啡属性
  - Facade
  - Flyweight
    - 享元模式采用一个共享来避免大量拥有相同内容对象的开销
    - String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。
  - Proxy
    - 代理模式
      - JDK动态代理依赖接口(底层ASM) 自动生成代理对象就是接口实现类执行代理方法时传入设置的拦截器调用其拦截方法
      - CGLIB动态代理基于父类(底层ASM) 创建增强器、设置目标对象为父类、设置拦截器、生成代理对象
- 行为模式
  - Chain of Responsibility
  - Command
  - Interpreter
  - Iterator
    - 迭代器模式(泛型迭代器)不关注各容器内部数据结构容器自己去实现自己的迭代方式
  - Mediator
  - Memento
  - Observer
    - 观察者模式(又叫`Publish/Subscribe发布-订阅模式`、`Model/View模型-视图模式`、`Source/Listener源-监听器模式`或`Dependents从属者模式`)定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
    - 观察者模式中，又分为推模型和拉模型两种方式
      - 推模型。主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。推模型是假定主题对象知道观察者需要的数据。
      - 拉模型。主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。
  - State
  - Strategy
    - 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。
    - 通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。
    - JDK中应用了策略模式接口`java.lang.Comparable#compareTo(java.lang.Object)`、`java.util.Comparator#compare(java.lang.Object, java.lang.Object)`
    - 示例中书店针对不通等级会员不同折扣的例子
  - Template Method
    - 模板方法所有重写的方法系统自动调用的都可以理解为模板方法
  - Visitor



[go src](./src/main/java/tk/deriwotua/dp/Test.java)