package tk.deriwotua.dp.D11_flyweight;

/**
 * 享元模式(以共享的方式高效地支持大量的细粒度对象)
 *  重复利用对象
 *
 *  java.lang.String 就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。
 *  JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。
 *      String a="abc"，其中"abc"就是一个字符串常量。
 * 享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。
 * 享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。
 *      一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。
 *      一个外蕴状态是随环境的改变而改变的、不可以共享的。
 *      享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。
 *      外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。
 *
 * 享元模式分为单纯享元模式、复合享元模式
 *
 * 享元模式的优缺点
 *      享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：
 *      享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
 *      享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。
 */
public class TestString {
    public static void main(String[] args) {
        /**
         * 字符串常量(单纯享元对象)
         */
        String s1 = "abc";
        String s2 = "abc";
        /**
         * 对象堆内存空间里存放了一个字符串常量(复合享元对象)
         */
        String s3 = new String("abc");
        String s4 = new String("abc");

        /**
         * 单纯享元模式可共享内蕴字符串常量所以结果true
         */
        System.out.println(s1 == s2); //true
        /**
         * 复合享元对象
         *  单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享
         *  即 s1 是单纯享元对象 而 s3 是复合享元对象(其内部是单纯享元对象)所以结果false
         */
        System.out.println(s1 == s3); //false
        // s3、s4都是复合享元对象 所以结果false
        System.out.println(s3 == s4);
        // s3 复合享元对象内部是单纯享元对象、s1 单纯享元对象 所以结果true
        System.out.println(s3.intern() == s1);
        // s3 复合享元对象内部是单纯享元对象、s4 复合享元对象内部是单纯享元对象 所以结果true
        System.out.println(s3.intern() == s4.intern());
    }
}
